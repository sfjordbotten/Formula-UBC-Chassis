\section{Truss FEA Scripts} \label{FEA Scripts}
	The truss FEA package created has two main sections:
	\begin{enumerate}
		\item Extracting 3D-sketch information from SolidWorks and parsing this data
		\item Analyzing the structure in MATLAB.
	\end{enumerate}

	The first section consists of a SolidWorks macro (genSketchInfoForMatlab.swp) that extracts the sketch information and a MATLAB function (parse\_SWoutput.m) that converts the SolidWorks output file into the input format for the second section. After these have been run, the output node and tube files must be manually filled to specify fixtures, loads, and material properties. Once this is complete, the data is ready for analysis in the second section.
	
	The second section consists of three classes (SpaceNode.m, SpaceTube.m and SpaceFrame.m). These classes represent nodes, tubes and the total space frame. The classes are extensively commented and contain documentation for each method.
		\subsection{genSketchInfoForMatlab.swp}
\begin{lstlisting}
Dim swApp As Object
Sub Main()
Dim swApp As SldWorks.SldWorks
Dim doc As SldWorks.ModelDoc2
Dim part As SldWorks.PartDoc
Dim sm As SldWorks.SelectionMgr
Dim feat As SldWorks.Feature
Dim sketch As SldWorks.sketch
Dim v As Variant
Dim i As Long
Dim sline As SldWorks.SketchLine
Dim sp As SldWorks.SketchPoint
Dim ep As SldWorks.SketchPoint
Dim s As String
Dim NumLines As Long

Set exApp = CreateObject("Excel.Application")
If Not exApp Is Nothing Then
	exApp.Visible = True
	If Not exApp Is Nothing Then
		exApp.Workbooks.Add
		Set sheet = exApp.ActiveSheet
		If Not sheet Is Nothing Then
			sheet.Cells(1, 1).Value = "Line"
			sheet.Cells(1, 2).Value = "Node1 X"
			sheet.Cells(1, 3).Value = "Node1 Y"
			sheet.Cells(1, 4).Value = "Node1 Z"
			sheet.Cells(1, 5).Value = "Node2 X"
			sheet.Cells(1, 6).Value = "Node2 Y"
			sheet.Cells(1, 7).Value = "Node2 Z"
		End If
	End If
End If


Set swApp = GetObject(, "sldworks.application")
If Not swApp Is Nothing Then
	Set doc = swApp.ActiveDoc
	If Not doc Is Nothing Then
		If doc.GetType = swDocPART Then
			Set part = doc
			Set sm = doc.SelectionManager
			If Not part Is Nothing And Not sm Is Nothing Then
				If sm.GetSelectedObjectType2(1) = swSelSKETCHES Then
					Set feat = sm.GetSelectedObject4(1)
					Set sketch = feat.GetSpecificFeature
					If Not sketch Is Nothing Then
						NumLines = sketch.GetLineCount2(1)
						v = sketch.GetLines2(1)
						For i = 0 To NumLines - 1
							If Not sheet Is Nothing And Not exApp Is Nothing Then
								sheet.Cells(2 + i, 1).Value = (i)
								sheet.Cells(2 + i, 2).Value = (v(12 * i + 6))
								sheet.Cells(2 + i, 3).Value = (v(12 * i + 7))
								sheet.Cells(2 + i, 4).Value = (v(12 * i + 8))
								sheet.Cells(2 + i, 5).Value = (v(12 * i + 9))
								sheet.Cells(2 + i, 6).Value = (v(12 * i + 10))
								sheet.Cells(2 + i, 7).Value = (v(12 * i + 11))
								exApp.Columns.AutoFit
							End If
							Next i
					End If
				End If
			End If
		End If
	End If
End If
End Sub
\end{lstlisting}			
		\subsection{parse\_SWoutput.m}
\begin{lstlisting}
function [nodes, tubes] = parse_SWoutput(fileName)
% parses data from solidworks macro to create spreadsheet for defining a
% space frame and its loads

	maxFileLines = 100000; % maximum number of file lines to scan
	
	file = fopen(fileName, 'r'); % open file
	fgets(file); % skip header line
	
	% tracks existing node positions
	nodePos = [];
	nodes = [];
	tubes = [];
	
	% search file, up to max 100000 lines
	for iii = 1 : maxFileLines
		line = fgets(file);
		if line == -1
			% found end of file
			break
		else
			% format of solidworks macro output is
			% [tube id, Node1 X, Node1 Y, Node1 Z, Node2 X, Node2 Y, Node2 Z]
			vars = textscan(line, '%f,%f,%f,%f,%f,%f,%f');
			tubeid = vars(1);
			tubeid = tubeid{1} + 1;
			node1 = vars(2 : 4);
			node1 = [node1{:}];
			node2 = vars(5 : 7);
			node2 = [node2{:}];
			if ~isempty(nodePos)
				ind = (nodePos(:, 1) == node1(1) & nodePos(:, 2) == node1(2) & nodePos(:, 3) == node1(3));
				if max(ind) == 0
					node1ID = length(nodes) + 1;
					nodes = [nodes, SpaceNode(node1ID , node1, [0, 0, 0])];
					nodePos = [nodePos; node1];
				else
					node1ID = find(ind);
				end
			
				ind = (nodePos(:, 1) == node2(1) & nodePos(:, 2) == node2(2) & nodePos(:, 3) == node2(3));
				if max(ind) == 0
					node2ID = length(nodes) + 1;
					nodes = [nodes, SpaceNode(node2ID , node2, [0, 0, 0])];
					nodePos = [nodePos; node2];
				else
					node2ID = find(ind);
				end
			else
				node1ID = 1;
				node2ID = 2;
				nodes = [SpaceNode(node1ID , node1, [0, 0, 0]), SpaceNode(node2ID , node2, [0, 0, 0])];
				nodePos = [node1; node2];
			end
		
			tubes = [tubes, SpaceTube(tubeid, nodes(node1ID), nodes(node2ID), -1, -1)];
		end
	end
	
	fclose(file);
	fileName = strrep(fileName, '.csv', '');
	nodeFile = fopen([fileName, '_nodes.csv'], 'w');
	fprintf(nodeFile, ['ID, X (m), Y (m), Z (m), Load X (N), Load Y (N), Load Z (N), Fixture X (0/1), Fixture Y (0/1), Fixture Z (0/1)\n']);
	
	for iii = 1 : length(nodes)
		node = nodes(iii);
		fprintf(nodeFile, '%i, %f, %f, %f, , , , , , ,', node.id, ...
		node.position(1), node.position(2), node.position(3));
		fprintf(nodeFile, '\n');
	end
	fclose(nodeFile);
	
	tubeFile = fopen([fileName, '_tubes.csv'], 'w');
	fprintf(tubeFile, ['ID, Node1, Node2, diameter (in), thickness (in), E (Pa), sigma_y (Pa), sigma_u (Pa)\n']);
	for iii = 1 : length(tubes)
		tube = tubes(iii);
		fprintf(tubeFile, '%i, %i, %i, , , , , ,\n', tube.id, tube.node1.id, tube.node2.id);
	end
	fclose(tubeFile);
	
	frame = SpaceFrame();
	for iii = 1 : length(nodes)
		frame.addNode(nodes(iii));
	end
	
	for iii = 1 : length(tubes)
		frame.addTube(tubes(iii));
	end
	
	frame.plotFrame();
end

\end{lstlisting}
		\subsection{SpaceNode.m}
\begin{lstlisting}
classdef SpaceNode < handle
	% Represents a node in a 3D space frame
	properties
		id % number to identify the node
		position % [m] the nodes position in cartesian co-ordinate, as a vector
		load % [N] external force on the node as a vector
		fixtures % vector defining whether or not there are reaction forces 0 = free, 1 = force
		reactions % [N] reaction force on the node as a vector
		tubes % list of tubes that end at the node
	end
	
	methods
		function obj = SpaceNode(id, position, fixtures)
		% constructs a node with the given ID and position
		% Parameters:
		%   -id (required): the id number for the node
		%   - position (required): [m] vector defining the cartesian
		%           co-ordiates of the node
			obj.id = id;
			obj.position = position;
			obj.load = [0, 0, 0];
			obj.reactions = [0, 0, 0];
			obj.fixtures = fixtures;
			obj.tubes = [];
		end
		
		function addLoad(obj, load)
			% Adds a load to the node
			% Parameters:
			%   - obj (required): the node to which the load will be added
			%   - load (required): [N] a vector defining the load to add to the
			%           node
			obj.load = obj.load + load;
		end
	end

end

\end{lstlisting}
		\subsection{SpaceTube.m}
\begin{lstlisting}
classdef SpaceTube < handle
	% Represents a tube in a 3D spaceframe
	
	properties
		id % number to identify the tube
		node1 % the node that defines one end of the tube
		node2 % the node that defines the second end of the tube
		diameter % [m] outside diameter of the tube
		thickness % [m] wall thickness of the tube
		E % [Pa] young's modulus for the tube material
		sigma_y % [Pa] yeild strength for the tube material
		sigma_u % [Pa] ultimate strength for the tube material
		unitVector % unit vector along the tube, pointing from node1 to node 2
		length % [m] length of the tube
		tubeVector % [m] vector with the magnitude and direction of the tube
		force % [N] the force acting on the tube
		stress % [Pa] the axial stress on the tube
	end
	
	methods
		function obj = SpaceTube(id, node1, node2, diameter, thickness, varargin)
		% Creates a tube as a straight line between the specified nodes and
		% with the specified geometric and material properties
		% Parameters:
		%   -id (required): a number to identify the node
		%   -node1 (required): the node where the tube starts
		%   -node2 (required): the node where the tube ends
		%   -diameter (required): the diameter of the tube in inches
		%   -thickness (required): the wall thickness of the tube in inches
		%   -E (optional name-value pair): the youngs modulus of the tube
		%           in Pascals. Corresponds to 4130 steel by default
		%   -sigma_y (optional name-value pair): yeild strength of the tube
		%           material in pascals. Corresponds to 4130 steel by default.
		%   -sigma_u (optional name-value pair): ultimate strength of the tube
		%           material in pascals.. Corresponds to 4130 steel by 
		%           default.
			p = inputParser;
			default_E = 100e9; % [Pa] TODO update to real value
			default_Sy = 100e6; % [Pa] TODO update to real value
			default_Su = 100e6; % [Pa] TODO update to real value
			addRequired(p, 'id', @isnumeric);
			addRequired(p, 'node1', @(x) isa(x, 'SpaceNode'));
			addRequired(p, 'node2', @(x) isa(x, 'SpaceNode'));
			addRequired(p, 'diameter', @isnumeric);
			addRequired(p, 'thickness', @isnumeric);
			addParameter(p, 'E', default_E, @isnumeric);
			addParameter(p, 'sigma_y', default_Sy, @isnumeric);
			addParameter(p, 'sigma_u', default_Su, @isnumeric);
			parse(p, id, node1, node2, diameter, thickness, varargin{:});
			
			% if inputs were valid, initialize tube properties
			obj.id = p.Results.id;
			obj.node1 = p.Results.node1;
			obj.node2 = p.Results.node2;
			obj.diameter = p.Results.diameter * 25.4 / 1000;
			obj.thickness = p.Results.thickness * 25.4 / 1000;
			obj.E = p.Results.E;
			obj.sigma_y = p.Results.sigma_y;
			obj.sigma_u = p.Results.sigma_u;
			obj.tubeVector = obj.node2.position - obj.node1.position;
			obj.length = norm(obj.tubeVector);
			obj.unitVector = obj.tubeVector./obj.length;
			
			obj.node1.tubes = [obj.node1.tubes, obj];
			obj.node2.tubes = [obj.node2.tubes, obj];
		end
		
		function calculateStress(obj)
		% calculates the stress in a tube based on its diameter, area,
		% thickness, and force applied
			area = (pi / 4) * (obj.diameter^2 - (obj.diameter - ...
			obj.thickness) ^ 2); % [m^2]
			obj.stress = obj.force / area; % [Pa]
		end
	end
end

\end{lstlisting}
		\subsection{SpaceFrame.m}
\begin{lstlisting}
% Represents a 3D space frame structure
classdef SpaceFrame < handle
	
	% Method comments duplicated so they are visible both when functions are
	% collapsed and when viewing class documentation via typing doc SpaceFrame
	% in the MATLAB console
	
	properties
	nodes % an array of nodes in the space frame
	tubes % an array of tubes in the space frame
	confinedNodes % list of nodes that are not free
	numReactionForces % list corresponding to confinedNodes with the number of reation forces at each node
	solved % boolean, true if the space frame has been solved
	maxStress % [Pa] max stress in the frame after solving
	minStress % [Pa] in stress in the frame after solving
	end
	
	methods
		function obj = SpaceFrame()
		% creates a new space frame with no nodes or tubes
			obj.nodes = [];
			obj.tubes = [];
			obj.confinedNodes = [];
			obj.solved = false;
			obj.maxStress = 0;
			obj.minStress = 0;
		end         
		
		function addNode(obj, node)
		% adds a node to the spaceframe
		% Parameters:
		%   - obj: the space frame object to which the node will be added
		%   - node: the node object to add
			if isa(node, 'SpaceNode')
				obj.nodes = [obj.nodes, node];
			
				if max(node.fixtures) ~= 0
					obj.confinedNodes = [obj.confinedNodes, node];
					obj.numReactionForces = [obj.numReactionForces, nnz(node.fixtures)];
				end
			else
				error('Only nodes can be added as a node')
			end
		end
		
		function createTube(obj, node1, node2, diameter, thickness)
		% creates a 4130 steel tube between node1 and node2
		% Parameters:
		%   - obj: the spaceframe in which the tube will be created
		%   - node1: the node object where the tube starts
		%   - node2: the node object where the tube ends
		%   - diameter: the tube diameter in inches
		%   - thickness: the tube thickness in inches
			id = length(obj.tubes);
			for iii = 1 : length(obj.tubes)
				tube = obj.tubes(iii);
				if tube.id > id
					id = tube.id + 1;
				end
			end
		
			obj.tubes = [obj.tubes, SpaceTube(id, node1, node2, diameter, thickness)];
		end
		
		function addTube(obj, tube)
		% adds the specified tube to the space frame
		% Parameters:
		%   - obj: the space frame to which the tube will be added
		%   - tube: the spaceTube object to add
			if isa(tube, 'SpaceTube')
				obj.tubes = [obj.tubes, tube];
			else
				error('Only tubes can be added as a tube')
			end
		end
		
		function plotFrame(obj)  
		% plots the space frame in a figure. If the frame is solved, tubes
		% are color coded by stress
			figure;
			hold on
			xlabel('X [m]');
			ylabel('Y [m]')
			zlabel('Z [m]')
			plottedNodeIds = [];
			
			if obj.solved
				colors = jet(1001);
				colormap jet
				bar = colorbar('eastoutside');
				set(bar, 'TickLabels', linspace(obj.minStress, obj.maxStress, 11))
				ylabel(bar, 'Stress [Pa]');
			end
			
			nodeX = zeros(1, length(obj.nodes));
			nodeY = zeros(1, length(obj.nodes));
			nodeZ = zeros(1, length(obj.nodes));
			nodeLabels = cell(1, length(obj.nodes));
			nodeInd = 1;
			
			for iii = 1 : length(obj.tubes)
				tube = obj.tubes(iii);
				x = zeros(1, 2);
				y = zeros(1, 2);
				z = zeros(1, 2);
				
				% plot node1 if not plotted
				if ~any(tube.node1.id==plottedNodeIds)
					plottedNodeIds = [plottedNodeIds, tube.node1.id]; 
					nodeX(nodeInd) = tube.node1.position(1);
					nodeY(nodeInd) = tube.node1.position(2);
					nodeZ(nodeInd) = tube.node1.position(3);
					nodeLabels(nodeInd) = {num2str(tube.node1.id)};
					nodeInd = nodeInd + 1;
				end
				
				% plot node2 if not plotted 
				if ~any(tube.node2.id==plottedNodeIds)
					plottedNodeIds = [plottedNodeIds, tube.node1.id];
					nodeX(nodeInd) = tube.node2.position(1);
					nodeY(nodeInd) = tube.node2.position(2);
					nodeZ(nodeInd) = tube.node2.position(3);
					nodeLabels(nodeInd) = {num2str(tube.node2.id)};
					nodeInd = nodeInd + 1;
				end
				x(1) = tube.node1.position(1);
				y(1) = tube.node1.position(2);
				z(1) = tube.node1.position(3);
				x(2) = tube.node2.position(1);
				y(2) = tube.node2.position(2);
				z(2) = tube.node2.position(3);
				text((x(2) + x(1)) / 2, (y(2) + y(1)) / 2,  (z(2) + z(1)) / 2, num2str(tube.id))
			
				if ~obj.solved
					plot3(x,y,z, 'b')
				else
					plot3(x, y, z, 'color', colors(floor(abs((tube.stress - obj.minStress) / (obj.maxStress - obj.minStress) * 1000)) + 1, :))
				end
			end
			
			plot3(nodeX, nodeY, nodeZ, 'bo')
			text(nodeX, nodeY, nodeZ, nodeLabels)
		end
		
		function [A, x, y] = solveFrame(obj)
		% creates the matrix defining the forces in the spaceframe and
		% solves. System of equations is defined as A * x = y where x is
		% the force on each tube or a reaction force and y is the applied
		% loads. The order of x is <tube forces>, <reaction forces> where
		% the tube forces are in the order they occur in obj.tubes and 
		% reaction forces are in the order they occur in obj.confinedNodes.
		
			% determine number of constraints
			constraints = 0;
			for iii = 1 : length(obj.confinedNodes)
				node =  obj.confinedNodes(iii);
				constraints = constraints + sum(node.fixtures);
			end
			
			% if there are less than 6 contraints, the frame is
			% underdefined and cannot be solved
			if constraints < 6
				error('Space frame is underconstrained and cannot be solved')
			end
			
			% check if the model is statically determinate (number of
			% unknowns <= number of equations
			if constraints + length(obj.tubes) > 3 * length(obj.nodes)
				error('Space frame is statically indeterminate and cannot be solved')
			end
			
			% System is described by
			%   A * x = y
			% where A is a matrix, x is a vector of tube forces and
			% reaction forces, and y is a vector of constants defined by
			% the geometry
			% matrix defining the system
			A = zeros(3 * length(obj.nodes), ...
			constraints + length(obj.tubes));
			
			y = zeros(3 * length(obj.nodes), 1);
			% the equation currently being created
			equation = 1;
			for iii = 1 : length(obj.nodes)
				node = obj.nodes(iii);
				for jjj = 1 : length(node.tubes)
					tube = node.tubes(jjj);
					direction = tube.unitVector; % default points from node1 to node2
					% ensure vector points away from the node (assume tubes
					% are in tension)
					if node == tube.node1
						% switch direction so it points from node2 to node1
						direction = -1 .* direction;
					end
		
					index = find(tube == obj.tubes);
					% node forces in x sum to zero
					A(equation, index) = direction(1);
					% node forces in y sum to zero
					A(equation + 1, index) = direction(2);
					% node forces in z sum to zero
					A(equation + 2, index) = direction(3);
				end
			
				index = find(node == obj.confinedNodes, 1);
				% if this node has reaction forces, add them to the matrix
				if ~isempty(index)
					% find the matrix column corresponding to the node's
					% reaction forces
					matIndex = length(obj.tubes) + 1;
					
					for jjj = 1 : index - 1
						matIndex = matIndex + obj.numReactionForces(jjj);
					end
					
					for jjj = 1 : 3
						% if the node has a reaction force
						if node.fixtures(jjj) ~= 0
							% add it to the matrix
							A(equation + jjj - 1, matIndex) = 1;
							matIndex = matIndex + 1;
						end
					end
				end
				
				% add node loads to the vector y
				y(equation) = node.load(1);
				y(equation + 1) = node.load(2);
				y(equation + 2) = node.load(3);
				
				equation = equation + 3;
			end
				
			% solve the system of equations
			solution = rref([A, y]);
			x = solution(:, end);
			
			for iii = 1 : length(x)
				if x(iii) ~= 0 && nnz(solution(iii, 1 : end - 1)) == 0
					error(['Cannot be solved. The model is unstable or one or more members or under bending.'])
				end
			end
			
			% assign results to tubes and calculate max/min stress
			max = 0;
			min = 0;
			for iii = 1 : length(obj.tubes)
				tube = obj.tubes(iii);
				tube.force = x(iii);
				tube.calculateStress();
				if tube.stress > max
					max = tube.stress;
				elseif tube.stress < min
					min = tube.stress;
				end
			end
			obj.maxStress = max;
			obj.minStress = min;
			
			% assign reaction forces to nodes
			iii = iii + 1;
			for jjj = 1 : length(obj.confinedNodes)
				node = obj.confinedNodes(jjj);
				node.reactions(node.fixtures == 1) = x(iii : iii + ...
				sum(node.fixtures) - 1);
				iii = iii + sum(node.fixtures);
			end
			
			obj.solved = true;
			% plot with stress
			obj.plotFrame();
		end
		
		function K = calcTorsionalStiffness(obj, torque)
		% calculates stiffness using energy methods, sum(strain energy in
		% tube) = work done by torque.
		% Parameters: 
		%   - obj: the space frame object
		%   - torque: the torque applied to the model
		% Returs:
		%   - K: stiffness of the space frame
			energy = 0; % [J] strain energy in tubes
			for i = 1 : length(obj.tubes)
				tube = obj.tubes(i);
				% strain energy = 1/(2E) * stress^2 * pi * area * length
				energy = energy + 1 / (2 * tube.E) * (tube.stress) ^ 2 * ...
				pi * ((tube.diameter / 2)^2 - (tube.diameter / 2 - ...
				tube.thickness) ^2) * tube.length;
			end
			
			% work = strain energy => T * theta / 2 = strain energy
			theta = (2 * energy / torque) * (180 / pi); % [degrees] angular deflection
			K = torque / theta; % [Nm/deg] stiffness
		end    
	end
	
	methods(Static)
		function obj = spaceFrameFromFiles(nodeFile, tubeFile)
		% creates a space frame object from csv files containing node and
		% tube information. csv files should be generated using the
		% following process:
		%   1. Make a 3D sketch in solidworks
		%   2. select the sketch and run the attached solidworks macro to
		%      generate an excel file with raw data
		%   3. Save the excel file as a csv
		%   4. Run the attached matlab function parse_SWoutput.m on the csv
		%      generated by the macro to generate the proper files for this
		%      package
		%   5. Fill in the node load and fixture information, and tube
		%      property information in the generated node and tube csv
		%      files.
		%   6. Pass the populated node and tube csv files to this function
		%      to create a spaceFrame for analysis
		% Parameters:
		%   - nodeFile: The csv containing node information generated by
		%               following the above process
		%   - tubeFile: the csv containing tube information generated by
		%               following the above process
		% Returns:
		%   - obj: a SpaceFrame object created from the specified files
			maxFileLines = 100000; % maximum number of file lines to scan
			obj = SpaceFrame(); % create empty frame to populate
			nodeFile = fopen(nodeFile); % open file with node info
			fgets(nodeFile); %skip header line
			
			for iii = 1 : maxFileLines
				line = fgets(nodeFile);
				if line == -1
					% found end of file
					break
				else
					% format of solidworks macro output is
					% [ID, X, Y, Z, Load X, Load Y, Load Z, Fixture X, 
					%  Fixture Y, Fixture Z, Tubes
					vars = textscan(line, '%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%s');
					id = vars{1};
					position = [vars{2:4}];
					load = [vars{5:7}];
					fixtures = [vars{8:10}];
					node = SpaceNode(id, position, fixtures);
					node.addLoad(load);
					obj.addNode(node);
				end
			end
			
			fclose(nodeFile); % close node file
			
			tubeFile = fopen(tubeFile); % open file with tube info
			fgets(tubeFile); %skip header line
			
			for iii = 1 : maxFileLines
				line = fgets(tubeFile);
				if line == -1
					% found end of file
					break
				else
					% format of solidworks macro output is
					% [ID, Node1, Node2, diameter, thickness, E, sigma_y,
					% sigma_u]
					vars = textscan(line, '%f,%f,%f,%f,%f,%f,%f,%f');
					id = vars{1};
					node1 = obj.nodes(vars{2});
					node2 = obj.nodes(vars{3});
					diameter = vars{4};
					thickness = vars{5};
					E = vars{6};
					sigma_y = vars{7};
					sigma_u = vars{8};
					tube = SpaceTube(id, node1, node2, diameter, thickness, ...
					'E', E, 'sigma_y', sigma_y, 'sigma_u', sigma_u);
					obj.addTube(tube);
				end
			end
			
			fclose(tubeFile); % close node file
		end
	end 
end

\end{lstlisting}
	